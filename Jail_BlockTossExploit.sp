#include <sourcemod>
#include <sdktools>
#include <cstrike>
#include <sdkhooks>

#undef REQUIRE_PLUGIN
#include "Jail_Mod.inc"

#define PLUGIN_AUTHOR "Trostal"
#define PLUGIN_VERSION "0.01a"

#pragma semicolon 1
#pragma newdecls required

#define PrintChatTag "\x01[\x0BJAIL\x01] :\x05" // 채팅에 출력할 때, 이 문자열을 앞에 두고 출력시킵니다.

#define T_COLOR 0xFF4040
#define CT_COLOR 0x99CCFF

#define TOSS_BLOCK_ACTIVATE_COUNT	5 // 몇 회나 총을 돌리면 방지 명령어가 발동될 것인가?
#define GUN_DISABLE_DURATION		60.0 // 방지 명령어가 발동되면 몇 초 동안 총이 비활성화 될 것인가?

#define WATING_TIME_UNTIL_DROP		8.0 // 죄수끼리 돌리는 총을 든 후, 여기에 지정된 시간(초) 동안 버리지 않으면 총을 돌리는게 아닌 것으로 간주한다.
#define WATING_TIME_UNTIL_PICK_UP	10.0 // 죄수끼리 돌리는 총을 든 후, 여기에 지정된 시간(초) 동안 아무도 들지 않으면 총을 돌리는게 아닌 것으로 간주한다.

KeyValues GunDataKeyValue = null;

public Plugin myinfo =
{
	name = "[JAIL] Block Prisoner Gun Toss Exploit",
	author = PLUGIN_AUTHOR,
	description = "총 돌리기 방지.",
	version = PLUGIN_VERSION,
	url = "https://github.com/Hatser/Jail-Mod"
};

public void OnPluginStart()
{
	if(GunDataKeyValue == INVALID_HANDLE)
	{
		GunDataKeyValue = new KeyValues("WeaponData");
		GunDataKeyValue.SetEscapeSequences(true);
	}
	
	HookEvent("round_end", OnRoundEnd);
}

public void OnMapEnd()
{
	ClearHandle(GunDataKeyValue);
}

public void OnMapStart()
{
	if(GunDataKeyValue == INVALID_HANDLE)
	{
		GunDataKeyValue = new KeyValues("WeaponData");
		GunDataKeyValue.SetEscapeSequences(true);
	}
}

public void OnPluginEnd()
{
	ClearHandle(GunDataKeyValue);
}

public void OnClientPutInServer(int client)
{
	SDKHook(client, SDKHook_WeaponEquipPost, OnClientEquipWeaponPost);
	SDKHook(client, SDKHook_WeaponDropPost, OnClientDropWeaponPost);
	SDKHook(client, SDKHook_WeaponCanUse, OnClientCanUseWeaponPre);
}

public void OnClientDisconnect(int client)
{
	SDKUnhook(client, SDKHook_WeaponEquipPost, OnClientEquipWeaponPost);
	SDKUnhook(client, SDKHook_WeaponDropPost, OnClientDropWeaponPost);
	SDKUnhook(client, SDKHook_WeaponCanUse, OnClientCanUseWeaponPre);
}

public void OnRoundEnd(Event event, char[] name, bool dontBroadcast)
{
	GunDataKeyValue.Rewind();
	GunDataKeyValue.DeleteThis();
}

public Action OnClientCanUseWeaponPre(int client, int weapon)
{
	if(GetClientTeam(client) != CS_TEAM_T || !IsValidEntity(weapon))
		return Plugin_Continue;
	
	char Classname[2][32];
	GetEntityClassname(weapon, Classname[0], sizeof(Classname[]));
	
	if(StrEqual(Classname[0][7], "knife") 
	|| StrEqual(Classname[0][7], "hegrenade") 
	|| StrEqual(Classname[0][7], "flashbang") 
	|| StrEqual(Classname[0][7], "smokegrenade") 
	|| StrEqual(Classname[0][7], "c4")
	|| StrEqual(Classname[0][7], "incgrenade")
	|| StrEqual(Classname[0][7], "molotov"))
		return Plugin_Continue;

	if(GunDataKeyValue == INVALID_HANDLE)
	{
		GunDataKeyValue = new KeyValues("WeaponData");
	}

	GunDataKeyValue.SetEscapeSequences(true);

	char KeyName[32];

	Format(KeyName, sizeof(KeyName), "%i", weapon);
	if(GunDataKeyValue.JumpToKey(KeyName))
	{
		GunDataKeyValue.Rewind();
		
		Format(KeyName, sizeof(KeyName), "%i/Classname", weapon);
		GunDataKeyValue.GetString(KeyName, Classname[1], sizeof(Classname[]));

		if(StrEqual(Classname[0], Classname[1], false))
		{
			Format(KeyName, sizeof(KeyName), "%i/Disabled_Time", weapon);

			if(GunDataKeyValue.GetFloat(KeyName, -GUN_DISABLE_DURATION) + GUN_DISABLE_DURATION >= GetGameTime())
			{
				return Plugin_Handled;
			}
			else
			{
				return Plugin_Continue;
			}
		}
	}
	return Plugin_Continue;
}

public void OnClientEquipWeaponPost(int client, int weapon)
{
	if(GetClientTeam(client) != CS_TEAM_T || !IsValidEntity(weapon))
		return;
	
	char Classname[2][32];
	GetEntityClassname(weapon, Classname[0], sizeof(Classname[]));
	
	if(StrEqual(Classname[0][7], "knife") 
	|| StrEqual(Classname[0][7], "hegrenade") 
	|| StrEqual(Classname[0][7], "flashbang") 
	|| StrEqual(Classname[0][7], "smokegrenade") 
	|| StrEqual(Classname[0][7], "c4")
	|| StrEqual(Classname[0][7], "incgrenade")
	|| StrEqual(Classname[0][7], "molotov"))
		return;

	if(GunDataKeyValue == INVALID_HANDLE)
	{
		GunDataKeyValue = new KeyValues("WeaponData");
	}

	GunDataKeyValue.SetEscapeSequences(true);

	char KeyName[32];

	Format(KeyName, sizeof(KeyName), "%i", weapon);
	if(GunDataKeyValue.JumpToKey(KeyName))
	{
		GunDataKeyValue.Rewind();

		GetEntityClassname(weapon, Classname[0], sizeof(Classname[]));

		Format(KeyName, sizeof(KeyName), "%i/Classname", weapon);
		GunDataKeyValue.GetString(KeyName, Classname[1], sizeof(Classname[]));

		if(StrEqual(Classname[0], Classname[1], false))
		{
			Format(KeyName, sizeof(KeyName), "%i/Pick_Time", weapon);
			GunDataKeyValue.SetFloat(KeyName, GetGameTime());

			Format(KeyName, sizeof(KeyName), "%i/Last_Owner", weapon);
			if(GunDataKeyValue.GetNum(KeyName) != client)
			{
				Format(KeyName, sizeof(KeyName), "%i/Drop_Time", weapon);
				if(GunDataKeyValue.GetFloat(KeyName, GetGameTime()) + WATING_TIME_UNTIL_PICK_UP >= GetGameTime())
				{
					Format(KeyName, sizeof(KeyName), "%i/Toss_Count", weapon);
					GunDataKeyValue.SetNum(KeyName, GunDataKeyValue.GetNum(KeyName)+1);

					if(GunDataKeyValue.GetNum(KeyName) >= TOSS_BLOCK_ACTIVATE_COUNT)
					{
						CS_DropWeapon(client, weapon, false, true);
						DisableTossedWeapon(weapon);
					}
				}	
			}
		}
	}
}

public void OnClientDropWeaponPost(int client, int weapon)
{
	if(IsValidClient(client))
		if(GetClientTeam(client) != CS_TEAM_T)
			return;
	
	if(!IsValidEntity(weapon))
		return;
	
	char Classname[32];
	GetEntityClassname(weapon, Classname, sizeof(Classname));
	if(StrEqual(Classname[7], "knife") 
	|| StrEqual(Classname[7], "hegrenade") 
	|| StrEqual(Classname[7], "flashbang") 
	|| StrEqual(Classname[7], "smokegrenade") 
	|| StrEqual(Classname[7], "c4")
	|| StrEqual(Classname[7], "incgrenade")
	|| StrEqual(Classname[7], "molotov"))
		return;

	if(GunDataKeyValue == INVALID_HANDLE)
	{
		GunDataKeyValue = new KeyValues("WeaponData");
		GunDataKeyValue.SetEscapeSequences(true);
	}

	GunDataKeyValue.SetEscapeSequences(true);

	char KeyName[32];

	GetEntityClassname(weapon, Classname, sizeof(Classname));

	Format(KeyName, sizeof(KeyName), "%i/Classname", weapon);
	GunDataKeyValue.SetString(KeyName, Classname);

	Format(KeyName, sizeof(KeyName), "%i/Drop_Time", weapon);
	GunDataKeyValue.SetFloat(KeyName, GetGameTime());

	Format(KeyName, sizeof(KeyName), "%i/Last_Owner", weapon);
	GunDataKeyValue.SetNum(KeyName, client);
}

void DisableTossedWeapon(int weapon)
{
	if(!IsValidEntity(weapon))
		return;

	if(GunDataKeyValue == INVALID_HANDLE)
	{
		GunDataKeyValue = new KeyValues("WeaponData");
		GunDataKeyValue.SetEscapeSequences(true);
	}

	GunDataKeyValue.SetEscapeSequences(true);

	char KeyName[32], Classname[32];

	GetEntityClassname(weapon, Classname, sizeof(Classname));

	Format(KeyName, sizeof(KeyName), "%i/Classname", weapon);
	GunDataKeyValue.SetString(KeyName, Classname);

	Format(KeyName, sizeof(KeyName), "%i/Disabled_Time", weapon);
	GunDataKeyValue.SetFloat(KeyName, GetGameTime());
	
	SetEntityRenderMode(weapon, RENDER_TRANSCOLOR);
	SetEntityRenderColor(weapon, 192, 0, 0, 255);
	
	PrintToChatAll("%s \x0F죄수들의 총 돌리기로 인해 무기가 1분간 잠김 상태로 설정됩니다.", PrintChatTag);

	SDKHook(weapon, SDKHook_OnTakeDamage, OnDisabledWeaponTakeDamage);
	CreateTimer(GUN_DISABLE_DURATION + 0.1, GunDisableTimer, weapon, TIMER_FLAG_NO_MAPCHANGE);
}

public Action GunDisableTimer(Handle timer, int weapon)
{
	if(GunDataKeyValue == INVALID_HANDLE)
	{
		GunDataKeyValue = new KeyValues("WeaponData");
	}

	if(!IsValidEntity(weapon))
		return Plugin_Stop;

	GunDataKeyValue.SetEscapeSequences(true);

	char KeyName[32], Classname[2][32];

	GetEntityClassname(weapon, Classname[0], sizeof(Classname[]));

	Format(KeyName, sizeof(KeyName), "%i/Classname", weapon);
	GunDataKeyValue.GetString(KeyName, Classname[1], sizeof(Classname[]));
	
	if(StrEqual(Classname[0], Classname[1], false))
	{
		Format(KeyName, sizeof(KeyName), "%i/Disabled_Time", weapon);
		if(GunDataKeyValue.GetFloat(KeyName) + GUN_DISABLE_DURATION	<= GetGameTime())
		{
			AbleTossedWeapon(weapon);
		}
		else
		{
			CreateTimer(GunDataKeyValue.GetFloat(KeyName) + GUN_DISABLE_DURATION - GetGameTime() + 0.1, GunDisableTimer, EntIndexToEntRef(weapon), TIMER_FLAG_NO_MAPCHANGE | TIMER_DATA_HNDL_CLOSE);
		}
	}
	return Plugin_Continue;
}

void AbleTossedWeapon(int weapon)
{
	if(GunDataKeyValue == INVALID_HANDLE)
	{
		GunDataKeyValue = new KeyValues("WeaponData");
	}
	
	weapon = EntRefToEntIndex(weapon);
	
	if(!IsValidEntity(weapon))
		return;

	GunDataKeyValue.SetEscapeSequences(true);

	char KeyName[32], Classname[2][32];

	Format(KeyName, sizeof(KeyName), "%i", weapon);
	if(GunDataKeyValue.JumpToKey(KeyName))
	{
		GunDataKeyValue.Rewind();

		GetEntityClassname(weapon, Classname[0], sizeof(Classname[]));

		Format(KeyName, sizeof(KeyName), "%i/Classname", weapon);
		GunDataKeyValue.GetString(KeyName, Classname[1], sizeof(Classname[]));

		if(StrEqual(Classname[0], Classname[1], false))
		{
			Format(KeyName, sizeof(KeyName), "%i/Classname", weapon);
			GunDataKeyValue.DeleteKey(KeyName);
			Format(KeyName, sizeof(KeyName), "%i/Disabled_Time", weapon);
			GunDataKeyValue.DeleteKey(KeyName);
			Format(KeyName, sizeof(KeyName), "%i/Drop_Time", weapon);
			GunDataKeyValue.DeleteKey(KeyName);
			Format(KeyName, sizeof(KeyName), "%i/Last_Owner", weapon);
			GunDataKeyValue.DeleteKey(KeyName);
			Format(KeyName, sizeof(KeyName), "%i/Toss_Count", weapon);
			GunDataKeyValue.DeleteKey(KeyName);
			Format(KeyName, sizeof(KeyName), "%i/Pick_Time", weapon);
			GunDataKeyValue.DeleteKey(KeyName);
			Format(KeyName, sizeof(KeyName), "%i", weapon);
			GunDataKeyValue.DeleteKey(KeyName);
			
			SetEntityRenderMode(weapon, RENDER_TRANSCOLOR);
			SetEntityRenderColor(weapon, 255, 255, 255, 255);
			
			SDKUnhook(weapon, SDKHook_OnTakeDamage, OnDisabledWeaponTakeDamage);
		}
	}
}

public Action OnDisabledWeaponTakeDamage(int weapon, int &attacker, int &inflictor, float& damage, int& damagetype)
{
	if(GetClientTeam(attacker) == CS_TEAM_CT)
		return Plugin_Continue;
	return Plugin_Stop;
}